# -*- coding: utf-8 -*-
"""LPM Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12YYIh27e2r4SIIkw-w3WfFRJE2NmHZgG
"""

!pip install gym==0.25.2
!pip install gymnasium shimmy
!pip install stable-baselines3 --no-deps

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.animation import FuncAnimation
from collections import defaultdict
import random
from IPython.display import HTML
import warnings
import gymnasium as gym
from stable_baselines3 import PPO
from gym import spaces, Env
from stable_baselines3.common.vec_env import DummyVecEnv

warnings.filterwarnings("ignore")

# Custom API and Environment Classes
class LLM_API:
    def __init__(self):
        self.customer_types = ["budget", "mid_range", "luxury", "tech_savvy", "eco_friendly"]
        self.product_categories = ["electronics", "clothing", "food", "home_decor", "books"]

    def generate_customer_profile(self):
        primary_type = random.choice(self.customer_types)
        budget = self.generate_budget(primary_type)
        return {
            "primary_type": primary_type,
            "budget": budget,
            "price_sensitivity": self.generate_price_sensitivity(primary_type)
        }

    def generate_budget(self, customer_type):
        base_budget = {
            "budget": np.random.normal(50, 20),
            "mid_range": np.random.normal(100, 30),
            "luxury": np.random.normal(200, 50),
            "tech_savvy": np.random.normal(150, 40),
            "eco_friendly": np.random.normal(120, 35)
        }
        return max(base_budget[customer_type], 0)

    def generate_price_sensitivity(self, customer_type):
        sensitivities = {
            "budget": np.random.uniform(0.7, 0.9),
            "mid_range": np.random.uniform(0.5, 0.7),
            "luxury": np.random.uniform(0.3, 0.5),
            "tech_savvy": np.random.uniform(0.4, 0.6),
            "eco_friendly": np.random.uniform(0.5, 0.7)
        }
        return sensitivities[customer_type]

    def generate_product(self):
        category = random.choice(self.product_categories)
        quality = random.choice(["low", "medium", "high"])
        eco_friendly = random.choice([True, False])
        tech_level = random.choice(["basic", "advanced", "cutting-edge"])
        base_price = np.random.uniform(10, 200)
        return {
            "category": category,
            "quality": quality,
            "eco_friendly": eco_friendly,
            "tech_level": tech_level,
            "base_price": base_price
        }

    def simulate_customer_decision(self, customer, product, price):
        decision_score = 1
        if customer["primary_type"] == "budget" and product["quality"] != "low":
            decision_score -= 0.3
        if customer["primary_type"] == "luxury" and product["quality"] != "high":
            decision_score -= 0.4
        if customer["primary_type"] == "tech_savvy" and product["tech_level"] == "basic":
            decision_score -= 0.3
        if customer["primary_type"] == "eco_friendly" and not product["eco_friendly"]:
            decision_score -= 0.4

        price_factor = min(1, customer["budget"] / price)
        decision_score *= price_factor ** customer["price_sensitivity"]

        return random.random() < decision_score

class Customer:
    def __init__(self, profile):
        self.profile = profile
        self.purchases = []

    def shop(self, store, llm):
        for product in store.products:
            if llm.simulate_customer_decision(self.profile, product.attributes, product.price):
                self.purchases.append(product)
                store.sales[product.id] += 1
                store.revenue += product.price

class Product:
    def __init__(self, id, attributes, initial_price):
        self.id = id
        self.attributes = attributes
        self.price = initial_price
        self.price_history = [initial_price]
        self.min_price = max(attributes["base_price"] * 0.5, initial_price * 0.7)
        self.max_price = min(attributes["base_price"] * 2, initial_price * 1.3)

class StoreEnv(Env):
    def __init__(self, products):
        super(StoreEnv, self).__init__()
        self.products = products
        self.revenue = 0
        self.sales = defaultdict(int)
        self.day = 0
        self.action_space = spaces.Box(low=-0.1, high=0.1, shape=(len(products),), dtype=np.float32)
        self.observation_space = spaces.Box(low=0, high=1, shape=(len(products) * 2 + 1,), dtype=np.float32)

    def reset(self):
        self.revenue = 0
        self.sales = defaultdict(int)
        self.day = 0
        return self._get_observation()

    def step(self, action):
        global heatmap_data
        for i, product in enumerate(self.products):
            product.price = np.clip(product.price * (1 + action[i]), product.min_price, product.max_price)
            product.price_history.append(product.price)

        seasonal_effect = 1 + np.random.uniform(-0.1, 0.1)
        num_customers_today = int(num_customers * seasonal_effect)
        daily_revenue_noise = np.random.uniform(0.95, 1.05)

        customers = [Customer(llm.generate_customer_profile()) for _ in range(num_customers_today)]
        for customer in customers:
            product_choice = random.choice(self.products)
            if llm.simulate_customer_decision(customer.profile, product_choice.attributes, product_choice.price):
                customer_type_idx = llm.customer_types.index(customer.profile["primary_type"])
                product_category_idx = llm.product_categories.index(product_choice.attributes["category"])
                heatmap_data[customer_type_idx, product_category_idx, self.day] += 1
                customer.shop(self, llm)

        self.revenue *= daily_revenue_noise
        reward = self.revenue
        self.day += 1
        done = self.day >= num_days
        return self._get_observation(), reward, done, {}

    def _get_observation(self):
        product_prices = np.array([product.price for product in self.products]) / 200.0
        product_sales = np.array([self.sales[product.id] for product in self.products]) / 10.0
        day_norm = self.day / num_days
        return np.concatenate([product_prices, product_sales, [day_norm]])

# Instantiate classes and setup
llm = LLM_API()
num_customers = 1000
num_products = 20
num_days = 30

heatmap_data = np.zeros((len(llm.customer_types), len(llm.product_categories), num_days))
products = [Product(i, llm.generate_product(), np.random.uniform(50, 150)) for i in range(num_products)]
env = DummyVecEnv([lambda: StoreEnv(products)])
model = PPO("MlpPolicy", env, verbose=0)
model.learn(total_timesteps=5000)

# Simulate environment
daily_revenue = []
store = StoreEnv(products)
obs = store.reset()
for day in range(num_days):
    action, _states = model.predict(obs)
    obs, rewards, done, info = store.step(action)
    daily_revenue.append(store.revenue)
    if done:
        obs = store.reset()

# Plotting and Animation
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

# Animation update function
def update(frame):
    for i, ax in enumerate(axes):
        if i != 3:
            ax.clear()

    # Daily Revenue plot
    axes[0].plot(daily_revenue[:frame + 1], color="blue")
    axes[0].set_title('Daily Revenue')
    axes[0].set_xlabel('Day')
    axes[0].set_ylabel('Revenue')

    # Price Adaptation for Selected Products
    for product in products[:5]:
        axes[1].plot(product.price_history[:frame + 1], label=f'Product {product.id}')
    axes[1].set_title('Price Adaptation for Selected Products')
    axes[1].set_xlabel('Day')
    axes[1].set_ylabel('Price')
    axes[1].legend()

    # Customer Type vs Product Category Heatmap
    sns.heatmap(heatmap_data[:, :, frame], ax=axes[2], annot=True, fmt=".0f",
                xticklabels=llm.product_categories, yticklabels=llm.customer_types, cbar=False)
    axes[2].set_title('Customer Type vs Product Category Heatmap')

    # Price Evolution of All Products Over Time (only changing plot)
    # if frame == num_days - 1:
    #     for product in products[:2]:
    #         axes[3].plot(product.price_history, label=f'Product {product.id}')
    #     axes[3].set_title('Price Evolution of All Products Over Time')
    #     axes[3].set_xlabel('Day')
    #     axes[3].set_ylabel('Price')
    #     axes[3].legend(loc='upper right', ncol=2)
    # else:
    #     axes[3].text(0.5, 0.5, "Price Evolution\n(available on final day)", ha='center', va='center', fontsize=12)
    #     axes[3].set_title('Price Evolution of All Products Over Time')
    # axes[3].axis('off')

# Set up the animation
# ani = FuncAnimation(fig, update, frames=num_days, repeat=False, interval=100)
# HTML(ani.to_jshtml())

# Set up the animation with a slower interval
ani = FuncAnimation(fig, update, frames=num_days, repeat=False, interval=500)  # Increase interval for slower animation
HTML(ani.to_jshtml())

